#include "MeshQtCSVImportExport.h"

// C++ includes
#include <iostream>

// GigaMesh includes
#include "mesh/vertex.h"
#include "mesh/mesh.h"

// Qt includes
#include <QString>
#include <QFileDialog>
#include <QFile>
#include <QTemporaryFile>
#include <QDateTime>

namespace {
//! \brief Constexpr value used as threshold to
//!        classify a file to be generated by the
//!        CSV export/import functions as large
//! \details Constexpr value used as threshold to
//!        classify a file to be generated by the
//!        CSV export/import functions as large.
//!        Import/export of large files will
//!        perform fewer GigaMesh GUI progress bar
//!        updates to speed up execution.
constexpr size_t largeFileSizeThreshold = 1000000;
}



//! \brief							This function is used to import
//!									Vertex object coordinates and
//!									function values from a CSV file
//! \details						This function is used to import
//!									Vertex object coordinates and
//!									function values from a CSV file.
//!									The data is checked for validity
//!									and missing components (index,
//!									x/y/z coordinate, function value).
//!									The number of imported values
//!									is checked to be the same as the
//!									number of Vertex objects present
//!									in the current mesh, as the
//!									coordinates and function values
//!									of the mesh are only updated, and
//!									no Vertex objects are added/
//!									removed from the mesh. The actual
//!									import of the data to the current
//!									mesh is only performed after these
//!									checks, to avoid incomplete
//!									imports. After a successful import,
//!									the Face object normals are updated,
//!									and a rerender of the mesh is
//!									triggered.
//! \param inputFilenameString		The filename and directory of the
//!									CSV file to import vertex
//!									coordinates/function values from
//! \return							True if the import was performed
//!									without error, false if an error
//!									occured on import
bool MeshQtCSVImportExport::importVertexDataFromCSV(const QString& inputFilenameString,
                                                        const std::function<void()>& boundingBoxChangedCallback)
{

	if(inputFilenameString.isEmpty() ||
	                inputFilenameString.isNull())
	{
		return false;
	}

	QFile vertexCoordinatesInputFile(inputFilenameString);

	if(vertexCoordinatesInputFile.open(QFile::ReadOnly | QFile::Text))
	{
		std::cout << "[MeshQtCSVImportExport::" << __FUNCTION__ << "] "
		        << "Opened file "
		        << vertexCoordinatesInputFile.fileName().toStdString()
		        << std::endl;
	}

	else
	{
		std::clog << "[MeshQtCSVImportExport::" << __FUNCTION__ << "] "
		            << "Error: Could not open file "
		            << vertexCoordinatesInputFile.fileName().toStdString()
		            << std::endl;
		return false;
	}

	m_showProgressStartFunction("Vertex coordinate import");


	// Bytes per line are not constant (they vary
	// with the exported data, as double to string
	// conversion was not set to fixed size), but
	// this is generally about the average number
	// of bytes per line
	constexpr size_t heuristicBytesPerLine = 50;
	constexpr size_t maximumReadSize = 100;

	const size_t heuristicNumberOfLines =
	                    vertexCoordinatesInputFile.size()/
	                                        heuristicBytesPerLine;

	const QRegExp matchDelimitersRegex("(\\ |\\t)");

	std::vector<std::pair<int, std::array<double, 4>>> vertexIndexPositionFunctionValueVector;

	QStringList matrixRowStringList;

	QByteArray lineBuffer;

	quint64 currentLineCount = 0;

	bool gotReadError = false;

	while(true)
	{

		lineBuffer = vertexCoordinatesInputFile.readLine(maximumReadSize);

		if(lineBuffer.size() <= 1)
		{
			break;
		}

		// Remove newline
		lineBuffer.remove(lineBuffer.size() - 1, 1);

		matrixRowStringList = QString(lineBuffer).split(
		                                        matchDelimitersRegex);

		// Remove all empty strings
		matrixRowStringList.removeAll(QString(""));

		++currentLineCount;

		bool conversionColoumn0SuccessFul = false;
		bool conversionColoumn1SuccessFul = false;
		bool conversionColoumn2SuccessFul = false;
		bool conversionColoumn3SuccessFul = false;
		bool conversionColoumn4SuccessFul = false;

		if(matrixRowStringList.size() == 5)
		{

			std::pair<int, std::array<double, 4>> indexPositionFunctionValuePair;

			indexPositionFunctionValuePair.first =
			                    matrixRowStringList.at(0).toInt(
			                            &conversionColoumn0SuccessFul);

			indexPositionFunctionValuePair.second.at(0) =
			                    matrixRowStringList.at(1).toDouble(
			                            &conversionColoumn1SuccessFul);

			indexPositionFunctionValuePair.second.at(1) =
			                    matrixRowStringList.at(2).toDouble(
			                            &conversionColoumn2SuccessFul);

			indexPositionFunctionValuePair.second.at(2) =
			                    matrixRowStringList.at(3).toDouble(
			                            &conversionColoumn3SuccessFul);

			indexPositionFunctionValuePair.second.at(3) =
			                    matrixRowStringList.at(4).toDouble(
			                            &conversionColoumn4SuccessFul);


			if(conversionColoumn0SuccessFul &&
			        conversionColoumn1SuccessFul &&
			        conversionColoumn2SuccessFul &&
			        conversionColoumn3SuccessFul &&
			        conversionColoumn4SuccessFul)
			{

				Vertex* currentVertex = m_meshGLPtr->getVertexByIdxOriginal(indexPositionFunctionValuePair.first);

				if(currentVertex != nullptr)
				{
					vertexIndexPositionFunctionValueVector.push_back(indexPositionFunctionValuePair);
				}

				else
				{
					gotReadError = true;

					std::clog << "[MeshQtCSVImportExport::" << __FUNCTION__ << "] "
					            << "Error: No corresponding vertex in the "
					            << "currently open mesh. The CSV file "
					            << "from which vertex coordinates are "
					            << "imported may have been exported from "
					            << "a differently sized mesh, or the CSV "
					            << "file is corrupted"
					            << std::endl;
					break;
				}

				if(heuristicBytesPerLine < largeFileSizeThreshold)
				{

					if(!(currentLineCount % 10))
					{
						const double currentStatus =
						                static_cast<double>(currentLineCount)/
						                static_cast<double>(heuristicNumberOfLines);

						m_showProgressFunction((currentStatus < 1.0 ? currentStatus : 1.0),
						                                                "Vertex coordinate import");
					}
				}

				else
				{
					if(!(currentLineCount % 100000))
					{
						const double currentStatus =
						                static_cast<double>(currentLineCount)/
						                static_cast<double>(heuristicNumberOfLines);

						m_showProgressFunction((currentStatus < 1.0 ? currentStatus : 1.0),
						                                                "Vertex coordinate import");
					}
				}
			}

			else
			{
				gotReadError = true;
				std::clog << "[MeshQtCSVImportExport::" << __FUNCTION__ << "] "
				            << ": Argument(s) ";

				if(!conversionColoumn0SuccessFul)
				{
					std::clog << matrixRowStringList.at(0).toStdString()
					            << " in index coloumn ";
				}

				if(!conversionColoumn1SuccessFul)
				{
					std::clog << matrixRowStringList.at(1).toStdString()
					            << " in x coordinate coloumn ";
				}

				if(!conversionColoumn2SuccessFul)
				{
					std::clog << matrixRowStringList.at(2).toStdString()
					            << " in y coordinate coloumn ";
				}

				if(!conversionColoumn3SuccessFul)
				{
					std::clog << matrixRowStringList.at(3).toStdString()
					            << " in z coordinate coloumn ";
				}

				if(!conversionColoumn4SuccessFul)
				{
					std::clog << matrixRowStringList.at(4).toStdString()
					            << " in feature vector element 0 coloumn ";
				}

				std::clog << "is/are invalid" << std::endl;

				break;
			}
		}

		else
		{
			gotReadError = true;

			std::clog << "[MeshQtCSVImportExport::" << __FUNCTION__ << "] "
			            << "Error: one or more row elements missing"
			            << std::endl;
			break;
		}
	}

	if( vertexIndexPositionFunctionValueVector.size() != m_meshGLPtr->getVertexNr() ) {
		gotReadError = true;

		std::clog << "[MeshQtCSVImportExport::" << __FUNCTION__ << "] "
		            << "Error: Imported mesh size doesn't match "
		            << "size of currently opened mesh" << std::endl;

	}

	if(!gotReadError)
	{
		std::cout << "[MeshQtCSVImportExport::" << __FUNCTION__ << "] Imported "
		            << currentLineCount - 1
		            << " coordinates" << std::endl;
	}

	else
	{
		std::clog << "[MeshQtCSVImportExport::" << __FUNCTION__ << "] "
		            << "In line " << currentLineCount
		            << " file: "
		            << vertexCoordinatesInputFile.fileName().toStdString()
		            << std::endl;
	}

	vertexCoordinatesInputFile.close();

	std::cout << "[MeshQtCSVImportExport::" << __FUNCTION__ << "] "
	            << "Closed input file "
	            << vertexCoordinatesInputFile.fileName().toStdString()
	            << std::endl;


	if(!gotReadError)
	{

		for(const std::pair<int, std::array<double, 4>> indexPositionFunctionValuePair :
		                                                    vertexIndexPositionFunctionValueVector)
		{
			Vertex* currentVertex = m_meshGLPtr->getVertexByIdxOriginal( indexPositionFunctionValuePair.first );


			if(currentVertex != nullptr)
			{
				currentVertex->setPosition(indexPositionFunctionValuePair.second.at(0),
				                            indexPositionFunctionValuePair.second.at(1),
				                            indexPositionFunctionValuePair.second.at(2));

				currentVertex->setFunctionValue(indexPositionFunctionValuePair.second.at(3));
			}

			else
			{
				std::cerr << "[MeshQtCSVImportExport::" << __FUNCTION__ << "] "
				            << "Error: Vertex " << indexPositionFunctionValuePair.first
				            << " not found in currently open mesh. "
				            << "This should have been detected while parsing "
				            << "the input file. Please report this bug to the "
				            << "development team"
				            << std::endl;

				return false;
			}
		}

		boundingBoxChangedCallback();

		double meshArea = 0.0;
		m_meshGLPtr->resetFaceNormals(&meshArea);

		std::cout << "[MeshQtCSVImportExport::" << __FUNCTION__ << "] "
		        << "Area of the mesh is now: "
		        << meshArea << " mmÂ² (unit assumed)."
		        << std::endl;

		//! Can also affect the polylines - reset them too
		m_meshGLPtr->polyLinesChanged();

	}

	m_showProgressStopFunction("Vertex coordinate import");

	return gotReadError;
}


//! \brief			Function to show a file dialog
//!					and trigger a Vertex object
//!					coordinates/function value import
//!					from a CSV file using the selected
//!					filename and directory
//! \return			True if the CSV Vertex object
//!					coordinates/function value import
//!					was performed without error, false
//!					if an error occured on import
bool MeshQtCSVImportExport::importVertexDataFromCSVDialog(const std::function<void()>& boundingBoxChangedCallback)
{
	const QString vertexCoordinatesInputFileDirectory =
	                                        QString::fromStdString( m_meshGLPtr->getFileLocation() );

	const QString vertexCoordinatesInputFileName =
	                        QFileDialog::getOpenFileName(nullptr,
	                                                        "TPS-RPM transformation matrix import",
	                                                        vertexCoordinatesInputFileDirectory,
	                                                        "CSV files (*.csv *.mat)");

	return importVertexDataFromCSV(
	                vertexCoordinatesInputFileName,
	                boundingBoxChangedCallback);
}


//! \brief						Function to print the indices/coordinates
//!								of the Currently selected Vertex objects
//!								of the mesh to the passed QTextStream
//!								object
//! \param outputTextStream		The QTextStream object to print the
//!								coordinates of the currently selected
//!								Vertex objects to
void MeshQtCSVImportExport::exportSelMVertsCoordinatesToCSV(QTextStream& outputTextStream)
{
	const size_t verticesToExportSize = m_meshGLPtr->mSelectedMVerts.size();

	size_t exportedVerticesCount = 0;

	std::pair<int, std::array<double, 3>> indexAndPositionPair;

	if(verticesToExportSize < largeFileSizeThreshold)
	{
		for(const Vertex* vertex : m_meshGLPtr->mSelectedMVerts)
		{
			vertex->getIndexAndCoordinates(indexAndPositionPair);

			outputTextStream << indexAndPositionPair.first << '\t'
			                                    << indexAndPositionPair.second.at(0) << '\t'
			                                    << indexAndPositionPair.second.at(1)<< '\t'
			                                    << indexAndPositionPair.second.at(2) << '\n';

			if(!(++exportedVerticesCount % 10))
			{
				m_showProgressFunction(static_cast<double>(exportedVerticesCount)/
				                                static_cast<double>(verticesToExportSize),
				                                "Coordinates of selected vertices export");
			}
		}
	}

	else
	{
		for(const Vertex* vertex : m_meshGLPtr->mSelectedMVerts)
		{
			vertex->getIndexAndCoordinates(indexAndPositionPair);

			outputTextStream << indexAndPositionPair.first << '\t'
			                                    << indexAndPositionPair.second.at(0) << '\t'
			                                    << indexAndPositionPair.second.at(1)<< '\t'
			                                    << indexAndPositionPair.second.at(2) << '\n';

			if(!(++exportedVerticesCount % 100000))
			{
				m_showProgressFunction(static_cast<double>(exportedVerticesCount)/
				                            static_cast<double>(verticesToExportSize),
				                            "Coordinates of selected vertices export");
			}
		}
	}
}

//! \brief						Function to print the indices/coordinates
//!								of the Vertex objects of the currently
//!								opened mesh to the passed QTextStream
//!								object
//! \param outputTextStream		The QTextStream object to print the
//!								coordinates of the Vertex objects of the
//!								currently opened mesh to the passed
//!								QTextStream object to
void MeshQtCSVImportExport::exportMVerticesCoordinatesToCSV(
                QTextStream& outputTextStream
) {
	const size_t verticesToExportSize = m_meshGLPtr->getVertexNr();

	size_t exportedVerticesCount = 0;

	std::pair<int, std::array<double, 3>> indexAndPositionVectorPair;

	std::vector<Vertex*>* vertices = m_verticesAccessorFunction();

	if(verticesToExportSize < largeFileSizeThreshold)
	{
		for(const Vertex* vertex : *vertices)
		{
			vertex->getIndexAndCoordinates(indexAndPositionVectorPair);

			outputTextStream << indexAndPositionVectorPair.first << '\t'
			                                    << indexAndPositionVectorPair.second.at(0) << '\t'
			                                    << indexAndPositionVectorPair.second.at(1)<< '\t'
			                                    << indexAndPositionVectorPair.second.at(2) << '\n';

			if(!(++exportedVerticesCount % 10))
			{
				m_showProgressFunction(static_cast<double>(exportedVerticesCount)/
				                                            static_cast<double>(verticesToExportSize),
				                                            "Vertex coordinates export");
			}
		}
	}

	else
	{
		for(const Vertex* vertex : *vertices)
		{
			vertex->getIndexAndCoordinates(indexAndPositionVectorPair);

			outputTextStream << indexAndPositionVectorPair.first << '\t'
			                                    << indexAndPositionVectorPair.second.at(0) << '\t'
			                                    << indexAndPositionVectorPair.second.at(1)<< '\t'
			                                    << indexAndPositionVectorPair.second.at(2) << '\n';

			if(!(++exportedVerticesCount % 100000))
			{
				m_showProgressFunction(static_cast<double>(exportedVerticesCount)/
				                                        static_cast<double>(verticesToExportSize),
				                                        "Vertex coordinates export");
			}
		}
	}
}


//! \brief							Function used to export either the
//!									indices/coordinates of the currently
//!									selected Vertex objects or all Vertex
//!									objects of the currently opened mesh to
//!									a file generated in the directory and
//!									with the filename contained in the
//!									passed QString object in CSV format
//! \param outputFilenameString		The QString object containing the
//!									directory in which the file will be
//!									created and the name of the file to be
//!									created
//! \param selectedVerticesOnly		If true is passed, only the indices/
//!									coordinates of the selected Vertex
//!									objects of the currently opened mesh
//!									are exported, if false is passed, the
//!									indices/coordinates of all Vertex
//!									objects of the currently opened mesh are
//!									exported
//! \return							True if the file has been generated and
//!									opened successfully, false if not
bool MeshQtCSVImportExport::exportVertexCoordinatesToCSV(const QString& outputFilenameString,
                                                    const bool selectedVerticesOnly)
{

	if(outputFilenameString.isEmpty() ||
	                outputFilenameString.isNull())
	{
		return false;
	}

	QTemporaryFile vertexCoordinatesTempFile;
	vertexCoordinatesTempFile.setAutoRemove(true);

	if(vertexCoordinatesTempFile.open())
	{
		std::cout << "[MeshQtCSVImportExport::" << __FUNCTION__ << "] "
		        << "Opened temp file "
		        << vertexCoordinatesTempFile.fileName().toStdString()
		        << std::endl;
	}

	else
	{
		std::clog << "[MeshQtCSVImportExport::" << __FUNCTION__ << "] "
		            << "Error: Could not open temp file"
		            << std::endl;
		return false;
	}

	vertexCoordinatesTempFile.setTextModeEnabled(true);

	if(selectedVerticesOnly)
	{
		m_showProgressStartFunction("Coordinates of selected vertices export");
	}

	else
	{
		m_showProgressStartFunction("Vertex coordinates export");
	}

	QTextStream vertexCoordinatesOutputTextStream(
	                                &vertexCoordinatesTempFile);

	if(selectedVerticesOnly)
	{
		exportSelMVertsCoordinatesToCSV(vertexCoordinatesOutputTextStream);
	}

	else
	{
		exportMVerticesCoordinatesToCSV(vertexCoordinatesOutputTextStream);
	}

	vertexCoordinatesTempFile.flush();
	vertexCoordinatesTempFile.close();

	if(QFile::exists(outputFilenameString))
	{
		if(QFile::remove(outputFilenameString))
		{
			std::cout << "[MeshQtCSVImportExport::" << __FUNCTION__ << "] "
			            << "Removed existing file "
			            << outputFilenameString.toStdString()
			            << std::endl;
		}

		else
		{
			std::clog << "[MeshQtCSVImportExport::" << __FUNCTION__ << "] "
			            << "Error: Could not delete existing file "
			            << outputFilenameString.toStdString()
			            << std::endl;
			return false;
		}
	}

	if(vertexCoordinatesTempFile.copy(outputFilenameString))
	{
		std::cout << "[MeshQtCSVImportExport::" << __FUNCTION__ << "] "
		            << "Copied data from temp file "
		            << vertexCoordinatesTempFile.fileName().toStdString()
		            << " to output file "
		            << outputFilenameString.toStdString()
		            << std::endl;
	}

	else
	{
		std::clog << "[MeshQtCSVImportExport::" << __FUNCTION__ << "] "
		            << "Error: Could not copy data from temp file "
		            << vertexCoordinatesTempFile.fileName().toStdString()
		            << " to output file "
		            << outputFilenameString.toStdString()
		            << std::endl;
		return false;
	}

	if(selectedVerticesOnly)
	{
		m_showProgressStopFunction(
		                "Coordinates of selected vertices export");
	}

	else
	{
		m_showProgressStopFunction(
		                "Vertex coordinates export");
	}

	return true;
}


//! \brief							Function to trigger a save filename
//!									generation dialog, and trigger an export
//!									of the indices/coordinates of either the
//!									selected Vertex objects or all Vertex
//!									objects of the currently opened mesh in
//!									CSV format
//! \param selectedVerticesOnly		If true is passed, only the indices/
//!									coordinates of the selected Vertex
//!									objects of the currently opened mesh
//!									are exported, if false is passed, the
//!									indices/coordinates of all Vertex
//!									objects of the currently opened mesh are
//!									exported
//! \return							True if the file has been generated and
//!									opened successfully, false if not
bool MeshQtCSVImportExport::exportVertexCoordinatesToCSVDialog(const bool selectedVerticesOnly)
{
	const QString vertexCoordinatesFileDirectory =
	                            QString::fromStdString( m_meshGLPtr->getFileLocation() );

	const QString vertexCoordinatesFileName =
	                            QFileDialog::getSaveFileName(nullptr,
	                                                            "Coordinate export of the selected vertices",
	                                                            vertexCoordinatesFileDirectory,
	                                                            "CSV files (*.csv *.mat)");

	return exportVertexCoordinatesToCSV(vertexCoordinatesFileName,
	                                            selectedVerticesOnly);
}

//! \brief							Function used to export the indices/
//!									coordinates of the currently selected
//!									Primitive objects to a file generated
//!									in the directory and with the filename
//!									contained in the passed QString object
//!									in CSV format using the selected
//!									filename/directory
//! \param outputFilenameString		The QString object containing the
//!									directory in which the file will be
//!									created and the name of the file to be
//!									created
//! \return							True if the file has beeen generated and
//!									opened successfully, false if not
bool MeshQtCSVImportExport::exportSelPrimsPositionsToCSV(const QString& outputFilenameString)
{

	if(outputFilenameString.isEmpty() ||
	                outputFilenameString.isNull())
	{
		return false;
	}

	QTemporaryFile selPrimsPositionsTempFile;
	selPrimsPositionsTempFile.setAutoRemove(true);

	if(selPrimsPositionsTempFile.open())
	{
		std::cout << "[MeshQtCSVImportExport::" << __FUNCTION__ << "] "
		        << "Opened temp file "
		        << selPrimsPositionsTempFile.fileName().toStdString()
		        << std::endl;
	}

	else
	{
		std::clog << "[MeshQtCSVImportExport::" << __FUNCTION__ << "] "
		            << "Error: Could not open temp file"
		            << std::endl;
		return false;
	}

	selPrimsPositionsTempFile.setTextModeEnabled(true);

	m_showProgressStartFunction("Positions of selected primitives export");

	QTextStream selPrimsPositionsOutputTextStream(
	                            &selPrimsPositionsTempFile);

	std::vector<std::tuple<Vector3D, Primitive*, bool>>* selectedPositions =
	                                                        m_selectedPositionsAccessorFunction();

	const size_t selPrimsPositionsToExportSize =
	                                selectedPositions->size();

	size_t exportedSelPrimsPositionsCount = 0;

	for(const std::tuple<Vector3D, Primitive*, bool> selectedPosition :
	                                                        *selectedPositions)
	{

		selPrimsPositionsOutputTextStream << std::get<0>(selectedPosition).getX() << '\t'
		                                    << std::get<0>(selectedPosition).getY() << '\t'
		                                    << std::get<0>(selectedPosition).getZ()<< '\n';

		m_showProgressFunction(static_cast<double>(exportedSelPrimsPositionsCount)/
		                                        static_cast<double>(selPrimsPositionsToExportSize),
		                                        "Positions of selected primitives export");
	}


	selPrimsPositionsTempFile.flush();
	selPrimsPositionsTempFile.close();

	if(QFile::exists(outputFilenameString))
	{
		if(QFile::remove(outputFilenameString))
		{
			std::cout << "[MeshQtCSVImportExport::" << __FUNCTION__ << "] "
			            << "Removed existing file "
			            << outputFilenameString.toStdString()
			            << std::endl;
		}

		else
		{
			std::clog << "[MeshQtCSVImportExport::" << __FUNCTION__ << "] "
			            << "Error: Could not delete existing file "
			            << outputFilenameString.toStdString()
			            << std::endl;
			return false;
		}
	}

	if(selPrimsPositionsTempFile.copy(outputFilenameString))
	{
		std::cout << "[MeshQtCSVImportExport::" << __FUNCTION__ << "] "
		            << "Copied data from temp file "
		            << selPrimsPositionsTempFile.fileName().toStdString()
		            << " to output file "
		            << outputFilenameString.toStdString()
		            << std::endl;
	}

	else
	{
		std::clog << "[MeshQtCSVImportExport::" << __FUNCTION__ << "] "
		            << "Error: Could not copy data from temp file "
		            << selPrimsPositionsTempFile.fileName().toStdString()
		            << " to output file "
		            << outputFilenameString.toStdString()
		            << std::endl;
		return false;
	}


	m_showProgressStopFunction("Positions of selected primitives export");

	return true;
}

//! \brief							Function to trigger a save filename
//!									generation dialog, and trigger an
//!									export of the coordinates of the
//!									selected Primitive objects of the
//!									currently opened mesh in CSV format
//!									using the selected filename/directory
//! \return							True if the file has beeen generated
//!									and opened successfully, false if not
bool MeshQtCSVImportExport::exportSelPrimsPositionsToCSVDialog()
{
	const QString selPrimsPositionsFileDirectory =
	                            QString::fromStdString( m_meshGLPtr->getFileLocation() );

	const QString selPrimsPositionsFileName =
	                            QFileDialog::getSaveFileName(nullptr,
	                                                            "Export of positions of "
	                                                            "selected primitives",
	                                                            selPrimsPositionsFileDirectory,
	                                                            "CSV files (*.csv *.mat)");

	return exportSelPrimsPositionsToCSV(
	                    selPrimsPositionsFileName);
}

